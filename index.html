<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paradise</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.js"></script>
</head>
<body>

  <!-- Екран входу -->
  <div class="login-screen" id="loginScreen">
    <h2>Вхід у парадайз</h2>
    <input type="password" id="passwordInput" placeholder="Введіть пароль" />
    <div id="nicknameSelection" style="display: none;">
      <p>Вибери свій нікнейм манюня моя:</p>
      <button onclick="chooseNickname('Baby 😎')">Baby 😎</button>
      <button onclick="chooseNickname('Pink Cloud ☁️')">Pink Cloud ☁️</button>
    </div>
    <button id="loginButton" onclick="checkPassword()">Увійти</button>
    <p id="loginError" style="color:red;"></p>
  </div>

  <!-- Чат -->
  <div class="chat-container" id="chatContainer" style="display: none;">
    <h1>🌸 ❤ Rakhiv Paradise ❤ 🌸</h1>
    <button id="openGalleryBtn" class="gallery-toggle-btn">🖼️</button>
    <div id="chat" class="chat-box"></div>
    <!-- Новий контейнер для індикатора набору тексту всередині чату -->
    <div id="chatTypingIndicator" class="typing-message-in-chat" style="visibility: hidden;"></div>
     <div class="media-controls-area">
      <div class="items">
          <button class="item-btn" onclick="playMusic('audio/Autumn-love.m4a', this)">🍂Любов як осінь🍂</button>
          <button class="item-btn" onclick="playMusic('audio/Bounty.mp3', this)">💖Bounty💖</button>
          <button class="item-btn" onclick="playMusic('audio/Drevo.mp3', this)">🌠Смарагдове небо🌠</button>
          <button class="item-btn" onclick="playMusic('audio/MBreeze.mp3', this)">🤗Кожен день🤗</button>
          <button class="item-btn" onclick="playMusic('audio/SoulScream.mp3', this)">🌌Крик у порожнечу🌌</button>
          <button class="item-btn" onclick="playMusic('audio/WhenYouSmile.mp3', this)">😊Коли ти посміхаєшся😊</button>          
          <button class="item-btn" onclick="playMusic('audio/song7.mp3', this)">🎧і тут</button>
          <button class="item-btn" onclick="playMusic('audio/song8.mp3', this)">🎷і тут</button>
          <button class="item-btn" onclick="playMusic('audio/song9.mp3', this)">🎺і тут</button>
      </div>
      <div class="volume-control">
        <button id="volumeToggleButton" class="item-btn">🔊</button>
        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.01" style="display: none;">
      </div>
    </div>
    <div class="input-controls">
      <textarea class="chat-input" id="msgInput" placeholder="Напиши повідомлення..." rows="1"></textarea>
      <button id="emojiToggleBtn" class="emoji-toggle-btn">😊</button>
      <input type="file" id="imageInput" accept="image/*" style="display: none;">
      <button id="attachImageBtn" class="attach-btn">📎</button>
      <button class="chat-button">💬</button>

      <div id="emojiPanel" class="emoji-panel" style="display: none;">
        <!-- Емодзі будуть завантажені сюди за допомогою JavaScript -->
      </div>
    </div>
    <div class="status-messages-container">
      <div id="users-online" class="users-online"></div>      
      <div id="imageUploadIndicator" class="upload-indicator" style="display: none;">Відправка зображення... 🖼️</div>
    </div>
  </div>

  <!-- Модальне вікно для зображень з чату -->
  <div id="chatImageDisplayModal" class="gallery-modal" style="display: none;">
    <button id="closeChatImageDisplayModalBtn" class="gallery-close-btn">&times;</button>
    <div class="gallery-content">
      <img id="chatDisplayImage" src="" alt="Збільшене зображення з чату" style="max-width: 90vw; max-height: 90vh; object-fit: contain;" />
    </div>
  </div>

  <!-- Модальне вікно галереї -->
  <div id="imageGalleryModal" class="gallery-modal" style="display: none;">
    <button id="closeGalleryBtn" class="gallery-close-btn">&times;</button>
    <div class="gallery-content">
      <button id="prevImageBtn" class="gallery-nav-btn prev-btn" aria-label="Previous image">&lt;</button>
      <div class="gallery-images-container" id="galleryImagesContainer">
        <!-- Зображення будуть завантажені сюди за допомогою JavaScript -->
      </div>
      <button id="nextImageBtn" class="gallery-nav-btn next-btn" aria-label="Next image">&gt;</button>
    </div>
  </div>
  <script>
    let selectedNickname = null;
    let socket = null;
    // Оголошуємо плеєр та пов'язані змінні тут, щоб вони були глобально доступні в межах скрипта
    const musicPlayer = new Audio();
    let currentPlayingButton = null;
    let currentSongSrc = null;

    const avatars = {
     "Baby 😎": "😎",
     "Pink Cloud ☁️": "☁️"
    };
    
    const userColors = {
     "Baby 😎": "message-baby",
     "Pink Cloud ☁️": "message-cloud"
    };

    function checkPassword() {
      const password = document.getElementById('passwordInput').value;
      const loginButton = document.getElementById('loginButton');
      if (password === "26060512") {
        document.getElementById('nicknameSelection').style.display = "block";
  passwordInput.style.display = "none"; // Приховуємо поле пароля
  loginButton.style.display = "none";   // Приховуємо кнопку "Увійти"
  document.getElementById('loginError').textContent = "";
      } else {
        document.getElementById('loginError').textContent = "Неправильний пароль.";
      }
    }

    function chooseNickname(nick) {
      selectedNickname = nick;
      document.getElementById('loginScreen').style.display = "none";
      document.getElementById('chatContainer').style.display = "flex";
      startChat();
    }

    function startChat() {
      socket = io("https://cloud-baby.onrender.com", {
        transports: ["websocket"]
      });

      socket.emit("register", selectedNickname); // передаємо нік


      socket.on("message", (data) => {
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message");
        messageDiv.dataset.messageId = data.messageId; // Додаємо ID повідомлення

        const colorClass = userColors[data.user];
        if (colorClass) messageDiv.classList.add(colorClass);

        if (data.type === 'image' && data.image) {
          const img = document.createElement('img');
          img.src = data.image;
          img.alt = "Зображення від " + data.user;
          img.classList.add('chat-image-thumbnail');
          img.onclick = () => displayChatImageFull(data.image);
          
          const senderInfo = document.createElement('span');
          senderInfo.textContent = `${avatars[data.user] || "👤"} ${data.user}: `;
          senderInfo.classList.add('message-sender');
          
          messageDiv.appendChild(senderInfo);
          messageDiv.appendChild(img);
        } else {
          messageDiv.textContent = `${avatars[data.user] || "👤"} ${data.user}: ${data.text}`;
        }

        // Додаємо кнопки дій, якщо повідомлення належить поточному користувачеві
        if (data.user === selectedNickname) {
          const actionsDiv = document.createElement("div");
          actionsDiv.classList.add("message-actions");

          const editButton = document.createElement("button");
          editButton.classList.add("action-btn", "edit-btn", "tooltip");
          editButton.innerHTML = "&#9998;"; // Іконка олівця
          editButton.title = "Редагувати";
          editButton.onclick = () => startEditMessage(data.messageId, messageDiv, data.type === 'text' ? data.text : null);
          if (data.type !== 'text') editButton.style.display = 'none'; // Редагуємо тільки текст

          const deleteButton = document.createElement("button");
          deleteButton.classList.add("action-btn", "delete-btn", "tooltip");
          deleteButton.innerHTML = "&#128465;"; // Іконка кошика
          deleteButton.title = "Видалити";
          deleteButton.onclick = () => deleteMessage(data.messageId);
          
          actionsDiv.appendChild(deleteButton); // Спочатку кнопка видалення
          actionsDiv.appendChild(editButton);   // Потім кнопка редагування
          messageDiv.appendChild(actionsDiv);
        }

        chat.appendChild(messageDiv);
        scrollToBottom();
      });
      socket.on("chat_history", (messages) => { // Оновлено для обробки зображень в історії
        messages.forEach(renderMessage); // Використовуємо нову функцію renderMessage
        scrollToBottom();
      });

      socket.on("users_online", (users) => {
        const usersOnlineDiv = document.getElementById('users-online');
        let displayString = "";

        const hasBaby = users.includes("Baby 😎");
        const hasCloud = users.includes("Pink Cloud ☁️");

        if (hasBaby && hasCloud) {
          displayString = `
            <div class="finger-lightning-container">
              <div class="finger left">👉</div>
              <div class="lightning"></div>
              <div class="finger right">👈</div>
            </div>
          `;
        } else if (hasBaby) {
          displayString = `<div class="finger-lightning-container"><div>👉</div></div>`;
        } else if (hasCloud) {
          displayString = `<div class="finger-lightning-container"><div>👈</div></div>`;
        }
        
        usersOnlineDiv.innerHTML = displayString || "Нікого немає в мережі";
      });

      socket.on("typing", (data) => {
        const chatTypingIndicator = document.getElementById("chatTypingIndicator"); // Новий індикатор
        if (data.typing) {          
          const userAvatar = avatars[data.user] || "👤"; // Визначаємо userAvatar тут
          chatTypingIndicator.textContent = `${userAvatar} ${data.user} шось там цікавеньке пише...люблячи тебе дуже сильно!`;
          chatTypingIndicator.style.visibility = 'visible';
          scrollToBottom(); // Прокрутити вниз, щоб було видно індикатор
        } else {
          chatTypingIndicator.style.visibility = 'hidden';
          // chatTypingIndicator.textContent = '\u00A0'; // Можна додати нерозривний пробіл, щоб гарантувати висоту, якщо min-height не спрацює
        }
      });


      socket.emit("get_history");

      const msgInput = document.getElementById("msgInput");
      let typingTimeout;

      msgInput.addEventListener("input", () => {
        socket.emit("typing", true);
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
          socket.emit("typing", false);
        }, 2000);
      });

      msgInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      document.querySelector(".chat-button").addEventListener("click", () => sendMessage());
      
      const attachImageBtn = document.getElementById('attachImageBtn');
      const imageInput = document.getElementById('imageInput');

      attachImageBtn.addEventListener('click', () => {
        imageInput.click(); // Відкрити діалог вибору файлу
      });

      imageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
          const uploadIndicator = document.getElementById('imageUploadIndicator');
          uploadIndicator.style.display = 'block'; // Показати індикатор

          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
              const canvas = document.createElement('canvas');
              const MAX_WIDTH = 800; // Максимальна ширина
              const MAX_HEIGHT = 600; // Максимальна висота
              let width = img.width;
              let height = img.height;

              if (width > height) {
                if (width > MAX_WIDTH) {
                  height *= MAX_WIDTH / width;
                  width = MAX_WIDTH;
                }
              } else {
                if (height > MAX_HEIGHT) {
                  width *= MAX_HEIGHT / height;
                  height = MAX_HEIGHT;
                }
              }
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);

              // Отримуємо стиснене зображення як JPEG з якістю 0.9 (можна змінювати)
              const compressedImageDataUrl = canvas.toDataURL('image/jpeg', 0.9); 

              socket.emit("message", { type: 'image', image: compressedImageDataUrl }, () => {
                uploadIndicator.style.display = 'none';
              });
            }
            img.src = e.target.result; // Завантажуємо оригінальне зображення для обробки
          }
          reader.readAsDataURL(file);
          imageInput.value = ''; // Скидаємо значення інпуту, щоб можна було вибрати той самий файл знову
        } else if (file) { // Якщо файл вибрано, але це не зображення
            alert("Будь ласка, виберіть файл зображення (JPEG, PNG, GIF).");
            uploadIndicator.style.display = 'none'; // Приховати індикатор, якщо файл не підходить
        }
      });
    }

    // Функція для рендерингу повідомлення (текст або зображення)
    function renderMessage(data) {
      const messageDiv = document.createElement("div");
      messageDiv.classList.add("message");
      messageDiv.dataset.messageId = data.messageId; // Додаємо ID повідомлення
      const colorClass = userColors[data.user];
      if (colorClass) messageDiv.classList.add(colorClass);

      if (data.type === 'image' && data.image) {
        const img = document.createElement('img');
        img.src = data.image;
        img.alt = "Зображення від " + data.user;
        img.classList.add('chat-image-thumbnail');
        img.onclick = () => displayChatImageFull(data.image);
        const senderInfo = document.createElement('span');
        senderInfo.textContent = `${avatars[data.user] || "👤"} ${data.user}: `;
        senderInfo.classList.add('message-sender'); // Додаємо клас для можливої стилізації
        messageDiv.appendChild(senderInfo);
        messageDiv.appendChild(img);
      } else {
        messageDiv.textContent = `${avatars[data.user] || "👤"} ${data.user}: ${data.text}`;
      }

       // Додаємо кнопки дій, якщо повідомлення належить поточному користувачеві
      if (data.user === selectedNickname) {
        const actionsDiv = document.createElement("div");
        actionsDiv.classList.add("message-actions");

        const editButton = document.createElement("button");
        editButton.classList.add("action-btn", "edit-btn", "tooltip");
        editButton.innerHTML = "&#9998;"; 
        editButton.title = "Редагувати";
        editButton.onclick = () => startEditMessage(data.messageId, messageDiv, data.type === 'text' ? data.text : null);
        if (data.type !== 'text') editButton.style.display = 'none'; 
        
        const deleteButton = document.createElement("button");
        deleteButton.classList.add("action-btn", "delete-btn", "tooltip");
        deleteButton.innerHTML = "&#128465;"; 
        deleteButton.title = "Видалити";
        deleteButton.onclick = () => deleteMessage(data.messageId);

        actionsDiv.appendChild(deleteButton); // Спочатку кнопка видалення
        actionsDiv.appendChild(editButton);   // Потім кнопка редагування
        messageDiv.appendChild(actionsDiv); 
      }

      chat.appendChild(messageDiv);
    }

    function sendMessage() {
      const msgInput = document.getElementById("msgInput");
      const msg = msgInput.value.trim();
      if (msg && socket) {
        socket.emit("message", { type: 'text', text: msg }); // Тепер відправляємо об'єкт
        msgInput.value = "";
      }
    }

    function scrollToBottom() {
      const chatBox = document.getElementById("chat");
      chatBox.scrollTop = chatBox.scrollHeight;
    }

        function playMusic(songSrc, buttonElement) {
      if (musicPlayer.src.includes(songSrc) && !musicPlayer.paused) {
        // Та сама пісня грає, ставимо на паузу
        musicPlayer.pause();
        buttonElement.classList.remove('playing');
        currentPlayingButton = null;
      } else if (musicPlayer.src.includes(songSrc) && musicPlayer.paused) {
        // Та сама пісня на паузі, продовжуємо відтворення
        musicPlayer.play()
          .then(() => {
            if (currentPlayingButton && currentPlayingButton !== buttonElement) {
              currentPlayingButton.classList.remove('playing');
            }
            buttonElement.classList.add('playing');
            currentPlayingButton = buttonElement;
          })
          .catch(error => console.error("Помилка продовження аудіо:", error));
      } else {
        // Нова пісня або інша вибрана
        if (currentPlayingButton) {
          currentPlayingButton.classList.remove('playing');
        }
        
        musicPlayer.src = songSrc;
        currentSongSrc = songSrc;
        musicPlayer.play()
          .then(() => {
            buttonElement.classList.add('playing');
            currentPlayingButton = buttonElement;
          })
          .catch(error => {
            console.error("Помилка відтворення нового аудіо:", error);
            currentSongSrc = null;
          });
      }
    }

    musicPlayer.onended = function() {
      if (currentPlayingButton) {
        currentPlayingButton.classList.remove('playing');
        currentPlayingButton = null;
      }
      currentSongSrc = null;
    };

    // --- Керування гучністю ---
    const volumeToggleButton = document.getElementById('volumeToggleButton');
    const volumeSlider = document.getElementById('volumeSlider');

    function updateVolumeIcon(volume) {
      if (volume === 0) {
        volumeToggleButton.textContent = '🔇';
      } else if (volume <= 0.33) {
        volumeToggleButton.textContent = '🔈';
      } else if (volume <= 0.66) {
        volumeToggleButton.textContent = '🔉';
      } else {
        volumeToggleButton.textContent = '🔊';
      }
    }

    // Ініціалізація гучності
    let initialVolume = parseFloat(localStorage.getItem('playerVolume'));
    if (isNaN(initialVolume) || initialVolume < 0 || initialVolume > 1) {
      initialVolume = 0.5; // Гучність за замовчуванням
    }
    musicPlayer.volume = initialVolume;
    volumeSlider.value = initialVolume;
    updateVolumeIcon(initialVolume);

    volumeToggleButton.addEventListener('click', () => {
      if (volumeSlider.style.display === 'none') {
        volumeSlider.style.display = 'inline-block'; // Або 'block' чи 'flex' залежно від бажаного вигляду
      } else {
        volumeSlider.style.display = 'none';
      }
    });

    volumeSlider.addEventListener('input', function() {
      musicPlayer.volume = this.value;
      updateVolumeIcon(parseFloat(this.value));
      localStorage.setItem('playerVolume', this.value);
    });

    // Закривати слайдер гучності, якщо клікнути деінде (опціонально)
    // document.addEventListener('click', function(event) {
    //   if (!volumeControl.contains(event.target) && volumeSlider.style.display !== 'none') {
    //     volumeSlider.style.display = 'none';
    //   }
    // });

    // --- Галерея зображень ---
    const openGalleryBtn = document.getElementById('openGalleryBtn');
    const closeGalleryBtn = document.getElementById('closeGalleryBtn');
    const imageGalleryModal = document.getElementById('imageGalleryModal');
    const galleryImagesContainer = document.getElementById('galleryImagesContainer');
    const prevImageBtn = document.getElementById('prevImageBtn');
    const nextImageBtn = document.getElementById('nextImageBtn');
    const chatDisplayModal = document.getElementById('chatImageDisplayModal');
    const emojiToggleBtn = document.getElementById('emojiToggleBtn');
    const emojiPanel = document.getElementById('emojiPanel');
    const chatDisplayImg = document.getElementById('chatDisplayImage');
    const closeChatImageDisplayBtn = document.getElementById('closeChatImageDisplayModalBtn');

    function displayChatImageFull(imageSrc) {
      chatDisplayImg.src = imageSrc;
      chatDisplayModal.style.display = 'flex';
      chatDisplayModal.classList.remove('hide');
      chatDisplayModal.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    if (closeChatImageDisplayBtn) {
      closeChatImageDisplayBtn.addEventListener('click', () => {
        chatDisplayModal.classList.remove('show');
        chatDisplayModal.classList.add('hide');
        setTimeout(() => {
          if (chatDisplayModal.classList.contains('hide')) {
            chatDisplayModal.style.display = 'none';
          }
          document.body.style.overflow = 'auto';
        }, 400); // Час має відповідати тривалості CSS анімації
      });
    }

    // ЗАМІНИ ЦІ ШЛЯХИ НА СВОЇ ЗОБРАЖЕННЯ В ПАПЦІ 'img'
    const galleryImageSources = [
      'img/1.jpg',
      'img/2.jpg',
      'img/3.jpg',
      'img/4.jpg',
      'img/5.jpg',
      'img/6.jpg',
      'img/7.jpg',
      'img/8.jpg',
      'img/9.jpg',
      'img/10.jpg'
      // Додай більше шляхів до зображень тут
    ];
    let imagesInGalleryLoaded = false;

    function populateGallery() {
      if (imagesInGalleryLoaded) return;
      galleryImagesContainer.innerHTML = ''; // Очистити попередні, якщо є
      galleryImageSources.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.alt = "Зображення з галереї";
        galleryImagesContainer.appendChild(img);
      });
      imagesInGalleryLoaded = true;
    }

    openGalleryBtn.addEventListener('click', () => {
      populateGallery();
      imageGalleryModal.style.display = 'flex'; // Спочатку робимо блок видимим
      imageGalleryModal.classList.remove('hide'); // Видалити клас hide, якщо він є
      imageGalleryModal.classList.add('show');
      document.body.style.overflow = 'hidden'; // Запобігти прокрутці фону
    });

    closeGalleryBtn.addEventListener('click', () => {
      imageGalleryModal.classList.remove('show');
      imageGalleryModal.classList.add('hide');
      
      // Зачекати завершення анімації перед тим, як приховати елемент і відновити прокрутку
      setTimeout(() => {
        // Якщо галерея все ще має клас 'hide' (тобто не була відкрита знову під час анімації)
        if (imageGalleryModal.classList.contains('hide')) {
          imageGalleryModal.style.display = 'none'; // Остаточно приховуємо елемент
        }
        document.body.style.overflow = 'auto'; // Відновити прокрутку фону
      }, 400); // Час має відповідати тривалості анімації fadeOutModal

    });

    prevImageBtn.addEventListener('click', () => {
      galleryImagesContainer.scrollBy({ left: -galleryImagesContainer.clientWidth, behavior: 'smooth' });
    });

    nextImageBtn.addEventListener('click', () => {
      galleryImagesContainer.scrollBy({ left: galleryImagesContainer.clientWidth, behavior: 'smooth' });
    });

    // --- Панель Емодзі ---
    const emojis = ['😀', '😂', '😊', '😍', '🤔', '😢', '😠', '👍', '👎', '❤️', '🎉', '✨', '🌸', '☁️', '😎', '🍂', '💖', '🌠', '🤗', '🌌', '😘', '😜', '😇', '🥳', '😭', '🙏', '👀', '👋', '🔥', '💯'];

    function populateEmojiPanel() {
      emojis.forEach(emoji => {
        const emojiSpan = document.createElement('span');
        emojiSpan.textContent = emoji;
        emojiSpan.setAttribute('role', 'button'); // Для доступності
        emojiSpan.setAttribute('tabindex', '0');  // Для доступності
        emojiSpan.addEventListener('click', () => insertEmoji(emoji));
        emojiSpan.addEventListener('keydown', (e) => { // Для доступності з клавіатури
          if (e.key === 'Enter' || e.key === ' ') {
            insertEmoji(emoji);
          }
        });
        emojiPanel.appendChild(emojiSpan);
      });
    }

    function insertEmoji(emoji) {
      const msgInput = document.getElementById('msgInput');
      const start = msgInput.selectionStart;
      const end = msgInput.selectionEnd;
      const text = msgInput.value;
      msgInput.value = text.substring(0, start) + emoji + text.substring(end);
      msgInput.focus();
      msgInput.selectionStart = msgInput.selectionEnd = start + emoji.length;
      // Можна автоматично ховати панель після вибору:
      // emojiPanel.style.display = 'none';
    }

    emojiToggleBtn.addEventListener('click', (event) => {
      event.stopPropagation(); // Зупиняємо спливання події, щоб не закрити панель одразу
      emojiPanel.style.display = emojiPanel.style.display === 'none' ? 'grid' : 'none';
    });

    document.addEventListener('click', (event) => {
      if (emojiPanel.style.display === 'grid' && !emojiPanel.contains(event.target) && event.target !== emojiToggleBtn) {
        emojiPanel.style.display = 'none';
      }
    });
    populateEmojiPanel(); // Заповнюємо панель емодзі при завантаженні

    // --- Редагування та Видалення Повідомлень ---
    if (socket) { // Переконуємося, що socket ініціалізований
      socket.on('message_edited', (data) => {
        const messageDiv = document.querySelector(`.message[data-message-id="${data.messageId}"]`);
        if (messageDiv && data.user === selectedNickname) { // Перевіряємо, чи це повідомлення поточного користувача
          // Оновлюємо текстовий вміст.
          const userPrefix = `${avatars[data.user] || "👤"} ${data.user}: `;
          let textNodeToUpdate = null;
          for (const child of messageDiv.childNodes) {
              // Шукаємо текстовий вузол, який не є .message-sender або .message-actions
              if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() !== '') {
                  textNodeToUpdate = child;
                  break;
              }
          }
          if (textNodeToUpdate) {
              textNodeToUpdate.textContent = userPrefix + data.newText;
          } else if (!messageDiv.querySelector('img')) { 
             // Якщо це було чисто текстове повідомлення, і ми не знайшли конкретний вузол,
             // спробуємо оновити textContent, але це може видалити інші дочірні елементи (наприклад, кнопки).
             // Тому цей випадок потребує обережності.
             // Для простоти, припустимо, що текстовий вузол завжди є.
             // Якщо його немає, можливо, потрібно буде відновити структуру повідомлення.
             // Поки що, якщо textNodeToUpdate не знайдено, нічого не робимо, щоб уникнути помилок.
             console.warn("Не вдалося знайти текстовий вузол для оновлення в message_edited для:", messageDiv);
          }
        } else if (messageDiv) {
            // Якщо повідомлення не поточного користувача, але воно оновилося (наприклад, адміном)
            // Тут можна додати логіку оновлення для інших користувачів, якщо потрібно
            const userPrefix = `${avatars[data.user] || "👤"} ${data.user}: `;
            let textNodeToUpdate = null;
            for (const child of messageDiv.childNodes) {
                if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() !== '') {
                    textNodeToUpdate = child;
                    break;
                }
            }
            if (textNodeToUpdate) {
                textNodeToUpdate.textContent = userPrefix + data.newText;
            }
        }
      });

      socket.on('message_deleted', (data) => {
        const messageDiv = document.querySelector(`.message[data-message-id="${data.messageId}"]`);
        if (messageDiv) {
          messageDiv.remove();
        }
      });
    }

    function deleteMessage(messageId) {
      if (confirm("Ви впевнені, що хочете видалити це повідомлення?")) {
        if (socket) {
          socket.emit('delete_message', { messageId });
        }
      }
    }

    function startEditMessage(messageId, messageDiv, currentText) {
      if (!currentText) return; 
      
      // Перевіряємо, чи вже не йде редагування цього повідомлення
      if (messageDiv.querySelector('.edit-message-input')) {
        return;
      }

      let originalTextNode = null;
      const userPrefix = `${avatars[selectedNickname] || "👤"} ${selectedNickname}: `;
      const expectedTextContent = userPrefix + currentText;

      for (const child of messageDiv.childNodes) {
        if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() === expectedTextContent.trim()) {
          originalTextNode = child;
          break;
        }
      }

      if (!originalTextNode) {
        // Спробуємо знайти текстовий вузол, що містить currentText, якщо точне співпадіння не знайдено
        // Це може бути корисно, якщо форматування тексту змінилося (наприклад, зайві пробіли)
        for (const child of messageDiv.childNodes) {
            if (child.nodeType === Node.TEXT_NODE && child.textContent.includes(currentText)) {
                originalTextNode = child;
                // Оновлюємо currentText до фактичного тексту з вузла без префіксу
                currentText = child.textContent.substring(userPrefix.length).trim();
                break;
            }
        }
        if (!originalTextNode) {
            console.error("Не вдалося знайти текстовий вузол для редагування в:", messageDiv, "Очікуваний текст:", currentText);
            return; 
        }
      }
      
      const actionsDiv = messageDiv.querySelector('.message-actions');
      let actionsWereVisible = false;
      if (actionsDiv) {
        actionsWereVisible = getComputedStyle(actionsDiv).display !== 'none';
        actionsDiv.style.display = 'none';
      }

      const input = document.createElement('textarea');
      input.classList.add('edit-message-input');
      input.value = currentText; // Використовуємо текст без префіксу
      input.rows = Math.max(1, Math.min(5, (currentText.match(/\n/g) || []).length + 1)); 
      input.onkeydown = (e) => { 
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          saveButton.click();
        } else if (e.key === 'Escape') {
          cancelButton.click();
        }
      };
      
      const saveButton = document.createElement('button');
      saveButton.textContent = 'Зберегти';
      saveButton.classList.add('action-btn', 'save-edit-btn');
      saveButton.onclick = () => {
        const newText = input.value.trim();
        // Відновлюємо вигляд перед відправкою на сервер, щоб уникнути подвійного оновлення
        // або якщо сервер не відповість
        messageDiv.replaceChild(originalTextNode, input);
        originalTextNode.textContent = userPrefix + (newText || currentText); // Оновлюємо текст одразу
        messageDiv.removeChild(saveButton);
        messageDiv.removeChild(cancelButton);
        if (actionsDiv && actionsWereVisible) actionsDiv.style.display = 'flex';

        if (newText && newText !== currentText) {
          if (socket) {
            socket.emit('edit_message', { messageId, newText });
          }
        }
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Скасувати';
      cancelButton.classList.add('action-btn', 'cancel-edit-btn');
      cancelButton.onclick = () => {
        messageDiv.replaceChild(originalTextNode, input);
        // originalTextNode.textContent залишається без змін (або можна відновити userPrefix + currentText)
        messageDiv.removeChild(saveButton);
        messageDiv.removeChild(cancelButton);
        if (actionsDiv && actionsWereVisible) actionsDiv.style.display = 'flex';
      };

      messageDiv.replaceChild(input, originalTextNode);
      input.insertAdjacentElement('afterend', cancelButton);
      input.insertAdjacentElement('afterend', saveButton);
      input.focus();
      input.select(); // Виділяємо текст для зручності редагування
    }
  </script>

</body>
</html>
